# 1. 시간복잡도



## 시간복잡도 정의

문제를 해결하기 위한 연산 횟수

1억번 연산 => 1초의 시



### 시간 복잡도 유형

* 빅-오메가 : **최선**일 때의 연산 횟수를 나타낸 표기법
* 빅-세타 : **보통**일 때의 연산 횟수를 나타낸 표기법
* **빅-오**(O(n)) : **최악**일 때의 연산 횟수를 나타낸 표기법 => 코테에선 최악의 경우를 생각해야함





## 시간 복잡도 활용



### 연산 횟수 계산 방법

연산 횟수 = 알고리즘 시간 복잡도 * 데이터의 크기



예시)

N개의 수가 주어졌을 때 이를 오름차순 정렬하는 프로그램 / 제한시간 2초 => 2억번 이하의 연산

1번째 줄에 수의 개수 N(1<= N <= 1,000,000), 2번째 줄부터는 N개의 줄에 숫자, 중복 없음



=> 버블 정렬 : N^2 으로 2억번 이상의 연산 소요 (2초 이상 소요)

=> 병합 정렬 : Nlog(N) 으로 약 2천만의 연산 소요 (약 0.2초)

=> 버블 정렬보다 병합 정렬이 더 적합한 알고리즘!



### 시간 복잡도를 바탕으로 코드 로직 개선

#### 시간 복잡도 도출 기준

1. 상수는 시간 복잡도 계산 제외 (N == 3N : 상수 3 무시)
2. 가장 많이 중첩된 반복문의 수행 횟수가 시간 복잡도의 기준 (일차원 for문 10개보다 이중, 삼중 for문이 연산 수가 많아짐)





#### 코테에서 시간복잡도 생각하기!

1. 알맞은 알고리즘 선택
2. 비효율적인 로직 찾아서 효율적으로 바꾸기





